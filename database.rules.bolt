function hasRole(role) { auth != null && auth.token[role] == true }
function isCoordinator() { hasRole('coordinator') }

type CurrentTimestamp extends Number {
  validate() { this == now }
}

type InitialTimestamp extends Number {
  validate() { this == (prior(this) == null ? now : prior(this)) }
}

type ReadOnlyCoordinator {
  read() { isCoordinator() }
}

type WriteOnlyCoordinator {
  write() { isCoordinator() }
}

type WriteOnlyCoordinatorField<T> extends T {
  write() { isCoordinator() }
}

path /donations {
  path /cash is ReadOnlyCoordinator {
    path /{push_id} {
      create() {
        return root.donations.tokens[this.token].valid == true
      }
    }
  }
}

path /users is ReadOnlyCoordinator {
  index() {[
    "emailAddress",
    "roles/CR",
    "roles/SQR",
    "roles/SE",
    "uploadCode"
  ]}
  
  path /{userId} {
    path /timestamp is CurrentTimestamp;
    path /isAvailableOnWhatsApp is Boolean;
    path /notes is WriteOnlyCoordinatorField<String>;
    path /emailAddress {
      create() { true }
    }
    path /languages {
      /{langName} is Boolean;
    }
    path /status is WriteOnlyCoordinatorField<String>;
    path /roles is WriteOnlyCoordinator {
      /{roleId} is Boolean;
    }
  }
}

// Original file name, for example BR-035A.
type OriginalFileName extends String {
  validate() { this.test(/^\w+-\d+/) }
}

// Task ID, for example ML2-135-3.
type TaskID extends String {
  validate() { this.test(/^\w+-\d+-\d{1,2}$/) }
}

// Status of the allotment.
// Can be either one of the predefined values or virtually any string.
type Status extends String {
  validate() { this.test(/^Spare|Given|WIP|Done|\w+(\s\w+)*]+$/) }
}

type SoundQualityRating extends String {
  validate() { this.test(/^Bad|Average|Good$/) }
}

type Assignee {
  emailAddress: String,
  name: String,
}

type Allotment {
  status: Status,
  assignee: Assignee | Null,
  notes: String | Null,
  timestampGiven: InitialTimestamp | Null,
  timestampDone: InitialTimestamp | Null,

  validate() {
    (this.status != 'Done' || this.timestampDone != null) &&
    (this.status == 'Spare' || (this.timestampGiven != null && this.assignee != null))
  }
}

type ReportingAllotment extends Allotment {
  token: String | Null,

  validate() { this.status == 'Spare' || this.token != null }
}

type Submission {
  created: InitialTimestamp,
  changed: CurrentTimestamp,
  completed: InitialTimestamp | Null,
  comments: String | Null,
}

type TimingInterval {
  beginning: String,
  ending: String,
}

type AudioChunkAnnotation extends TimingInterval {
  entireFile: Boolean,
  type: String,
  description: String,
}

type SQRSubmission extends Submission {
  duration: TimingInterval | Null,
  soundQualityRating: SoundQualityRating | Null,
  soundIssues: AudioChunkAnnotation[] | Null,
  unwantedParts: AudioChunkAnnotation[] | Null,
}

function tokenIsValid(token, fileName, phase) {
  return phase.allotments[fileName].token == token;
}

path /SQR {
  path /allotments is Map<OriginalFileName, ReportingAllotment> {
    index() { ["status", "assignee/emailAddress", "token"] }
  }

  path /submissions {

    // Draft submissions, writable by anyone who knows the token.
    path /drafts/{fileName}/{token} is SQRSubmission {
      read() { true }
      write() { true }
    }

    // Completed submissions, writable only if the token is valid.
    // This path triggers submission processing.
    path /completed/{fileName}/{token} is SQRSubmission {
      read() { true }
      create() { tokenIsValid(this.token, fileName, root.SQR) }
      update() {
        tokenIsValid(this.token, fileName, root.SQR)
        &&
        (isCoordinator() || root.SQR.allotments[fileName].status == 'WIP')
      }
    }

    // Cold storage for the submission, writable only by the function.
    path /final/{fileName} is SQRSubmission;
  }
}

type AudioChunk extends TimingInterval {
  fileName: String,
}

type Resolution {
  timstamp: InitialTimestamp,
  isApproved: Boolean,
  feedback: String,

  create() { isCoordinator() }
}

type TrackEditingVersion {
  timestamp: InitialTimestamp,
  uploadPath: String, // Path in the `uploads` bucket
  resolution: Resolution | Null,
}

type TrackEditingTask extends Allotment {
  chunks: AudioChunk[],
  unwantedParts: AudioChunkAnnotation[],
  versions: TrackEditingVersion[],
}

path /TE {
  path /tasks is Map<TaskID, TrackEditingTask> {
    index() { ["status", "assignee/emailAddress"] }
  }
}
